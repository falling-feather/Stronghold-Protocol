想象你有一排编号为1到n的宝石，每颗宝石的价值等于它的编号。你的任务是把这些宝石分成两堆，让两堆的总价值相等。

DP状态的含义
dp[i][j] 表示：前i颗宝石中，能组成价值为j的方案数

i：考虑前i个数字（1到i）
j：目标是组成和为j的组合
dp[i][j]：有多少种不同的组合方式
决策过程：每颗宝石的选择
对于第i颗宝石（价值为i），你有两个选择：

不拿这颗宝石 👉 方案数 = dp[i-1][j]
拿这颗宝石 👉 方案数 = dp[i-1][j-i]（前提是j≥i）
总方案数 = 不拿的方案数 + 拿的方案数

举个具体例子：n=4
总和 = 1+2+3+4 = 10，目标是选出和为5的组合

初始状态：
dp[0][0] = 1 （不用任何数字组成0，有1种方案）
dp[0][1...5] = 0 （不用任何数字组成正数，不可能）

考虑数字1：
- dp[1][0] = 1 （不拿1）
- dp[1][1] = 1 （拿1）
- dp[1][2...5] = 0

考虑数字2：
- dp[2][0] = 1 （不拿1和2）
- dp[2][1] = 1 （不拿2，只拿1）
- dp[2][2] = 1 （拿2，不拿1）
- dp[2][3] = 1 （拿1和2）
- dp[2][4...5] = 0

考虑数字3：
- dp[3][0] = 1
- dp[3][1] = 1
- dp[3][2] = 1
- dp[3][3] = 2 （拿3或拿1+2）
- dp[3][4] = 1 （拿1+3）
- dp[3][5] = 1 （拿2+3）

考虑数字4：
- dp[4][5] = 3 （不拿4时的方案数dp[3][5]=1 + 拿4时的方案数dp[3][1]=1）
最终 dp[4][5] = 3，但因为两堆是无区别的，所以答案是3/2=1（向下取整）

状态转移的可视化
    和: 0  1  2  3  4  5
数  ─────────────────────
字  0:  1  0  0  0  0  0
空  1:  1  1  0  0  0  0
集  2:  1  1  1  1  0  0
    3:  1  1  1  2  1  1
    4:  1  1  1  2  2  3
每一步的计算都遵循：dp[i][j] = dp[i-1][j] + dp[i-1][j-i]

这就是背包DP的精髓：通过前面的计算结果，逐步构建出更复杂情况的解！