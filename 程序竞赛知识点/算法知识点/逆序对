给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i < j 且 a[i] > a[j]，则其为一个逆序对；否则不是。

输入格式:
第一行包含整数n，表示数列的长度；第二行包含 n 个整数，表示整个数列。（1≤n≤100000）

输出格式:
输出一个整数，表示逆序对的个数。

输入样例:
6
2 3 4 5 6 1
输出样例:
5


题解：排序的过程就是消除逆序对的过程。逆序对越多，相对来说排序所需要的时间就越多。

借助冒泡排序的话，每一次交换都会消除一个逆序对，交换一个相邻的逆序对，不会影响到其它的逆序对，所以可以计算冒泡排序在排序过程一共进行了多少次交换，由此得出数组的逆序对数。最普通的冒泡排序和枚举的循环次数一样多。但是枚举的过程没有元素交换，会比使用冒泡排序计算逆序对数快很多。

借助冒泡排序只需要在交换两个元素的同时逆序对计数加1即可。普通的冒泡算法会试遍所有的组合，而改进的冒泡算法则可以减少这些检查，逆序对数少时就比枚举法快很多，但是逆序对数多的话就不行，因为排序有很大一部分时间花在元素交换上。
缺点是计算的过程会消除逆序对，计算完成后，逆序对也被消除了，如果想保留数列，则需要复制数组，使用副本计算。

时间复杂度为o（n2）

借助插入排序的话，插入排序的每一次元素移动可以看做相邻元素互换， 移动一次就消除一个逆序。
  所以可以用插入排序计算逆序对数，并且比用冒泡排序快。

时间复杂度为o（n2）

借助归并排序，  一个升序数组，逆序对为0。数组中一个连续段之间的逆序对交换，只会影响段内的逆序对数，而不会影响段外的逆序对，段外的元素与段内的元素之间的逆序对数也不受影响
  将一个数组A从中间分成左右两部分， 分别是  A [ l e f t ] . . . A [ m i d ] 和 A [ m i d + 1 ] . . . A [ r i g h t ] \ A[ left ]...A[mid] 和 A[mid+1]...A[right] A[left]...A[mid]和A[mid+1]...A[right]。
  假设两部分分别有序，在归并过程中，i， j 分别表示左右两部分归并到的元素下标, 必有i < j。如果有A[i] > A[j]， 那么左边A[i]之后的元素也都会大于A[j], 所以A[j] 与 A[i] 到A[mid]的逆序对为   m i d − i + 1 \ mid - i +1 mid−i+1。
  归并排序的两个有序数列归并，这两个有序数列在数组中是相邻的，所以交换这两个数列的元素，只会影响这两个数列元素之间的逆序对数。
  由此修改归并排序来计算逆序对， 逆序对在归并时计算。为了简便，就使用最普通的递归归并排序来说明。

下面的临时数组是全局变量，是为了方便。如果想要把整个计算过程封装到函数内，可以参考递归归并排序的避免频繁开辟内存写法。
时间复杂度为O ( n log ⁡ n ) 
