基本思想
首先把循环可以进行的条件写成 while left <= right，在退出循环的时候，一定有 left == right 成立，此时返回 nums[mid] 中对应的 mid 即可。

深层次的思想是“夹逼法”或者称为“排除法”——二分查找算法的基本思想。
“排除法”：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼”只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。
代码模板
下面的代码包含闭区间、左闭右开区间和开区间三种写法。选择自己喜欢的一种写法即可。

binary_search 返回最小的满足 nums[i] >= target 的 i
如果数组为空，或者所有数都小于 target，则返回 len(nums)
要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

# 闭区间写法
def binary_search1(nums, target):
    left, right = 0, len(nums) - 1  # 闭区间 [left, right]
    while left <= right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right+1] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # 范围缩小到 [mid+1, right]
        else:
            right = mid - 1  # 范围缩小到 [left, mid-1]
    return left

# 左闭右开区间写法
def binary_search2(nums, target):
    left = 0
    right = len(nums)  # 左闭右开区间 [left, right)
    while left < right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # 范围缩小到 [mid+1, right)
        else:
            right = mid  # 范围缩小到 [left, mid)
    return left  # 返回 left 还是 right 都行，因为循环结束后 left == right

# 开区间写法
def binary_search3(nums: List[int], target: int) -> int:
    left, right = -1, len(nums)  # 开区间 (left, right)
    while left + 1 < right:  # 区间不为空
        mid = (left + right) // 2
        # 循环不变量：
        # nums[left] < target
        # nums[right] >= target
        if nums[mid] < target:
            left = mid  # 范围缩小到 (mid, right)
        else:
            right = mid  # 范围缩小到 (left, mid)
    return right