//note P2158 [SDOI2008] 仪仗队
//! 时间限制
// 1.00s
//! 内存限制
// 125.00MiB
//! 题目描述
// 作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 N×N 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐
// 现在，C 君希望你告诉他队伍整齐时能看到的学生人数。
// !输入格式
// 一行，一个正整数 N。
//! 输出格式
// 输出一行一个数，即 C 君应看到的学生人数。
//! 输入输出样例
//? 输入#1	4
//? 输出#1	9
// 说明/提示
// 对于 100% 的数据，1≤N≤40000。

// todo 解析
//? 题目背景：
// 该题目要求计算在一个n*n的方阵中，位于（1，1）位置的人能看到的学生人数。
// 视线被阻挡的规则是：只要某两个学生和位于（1，1）位置的学生在同一条直线上，
// 且距离（1，1）位置的学生更远，那么更远的学生将被前面的学生挡住。

// 由此可知，此题的核心就是查询有多少种不同的斜率在方阵中存在
// 或者说，有多少个不可约分的分数 a/b 满足 1 ≤ a, b < n。
// 更通俗的讲，就是求方阵中的元素有多少是互质数对。

//? 解题思路：
//zw 1. 互质数对的定义：
//    两个整数 a 和 b 如果它们的最大公约数 gcd(a, b) = 1，则称它们是互质的。
//zw 2. 欧拉函数（Euler's Totient Function）：
//    欧拉函数 φ(k) 定义为小于等于 k 且与 k 互质的正整数的个数。
//    关于欧拉函数的具体知识点可以参考手写资料，在其中已经推到了欧拉函数的一个一般化公式。
//? 计算方法：
//    初始化一个数组 oula，其中 oula[i] = i。
//    我们知道的是，对于欧拉函数φ(k)，如果 k 有一个质因子 p，那么：
//zw    φ(k) = k * (1 - 1/p)
//     借助这一点，我们参考埃氏筛法的思想来计算所有整数的欧拉函数值。
//     遍历从2到n的整个oula数组，对于每个数i，我们会检查它是否为质数。
//     检查方法为：由于i从2开始遍历，2是质数，每次检查到一个质数后都会将其倍数的欧拉函数值进行更新。
//     更新公式为：oula[j] = oula[j] / i * (i - 1)，其中 j 是 i 的倍数。
//     检查质数的规则为：如果 i 是质数，那么 oula[i] = i - 1。
//     不过由于在先前我们填充数组时，已经将 i 的倍数进行更新，因此此时 oula[i] = i。

// zw    特殊的：对于1，我们直接认为结果为0，因为此时只有他自己，他看不到任何人。

/// 代码实现：
#include <bits/stdc++.h>
using namespace std;
int oula[114514];
int main() 
{
    int n;
    cin >> n;
    int count = 0;
    if (n == 1) 
    //特殊的，如果只有1个人，那么他看到的人数为0
    {
        cout << 0 << endl;
        return 0;
    }
    for (int i = 1; i <= n; i++)
    {
        oula[i] = i;
    }
    for (int i = 2; i <= n; i++)
    {
        if (oula[i] == i)
        {
            for (int j = i; j <= n; j += i)
            // j 从 i 开始，每次增加 i，遍历所有 i 的倍数,对其适用欧拉筛的计算方法，进行欧拉筛。
            {
                oula[j] = oula[j] / i * (i - 1);
            }
        }
    }
    for (int i = 1; i < n; i++)
    {
        count += oula[i];
    }
    cout << count * 2 + 1 << endl;
    //这里涉及到了整体的优化思路，虽然是一个方阵，但是我们只需要计算一个下三角或者上三角的范围就已然足够。最终加上对角线上的1即可。
    return 0;
}