// 题目描述
// 对于从 1∼n 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 n=3，对于 {1,2,3} 能划分成两个子集合，每个子集合的所有数字和是相等的：
// {3} 和 {1,2} 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）
// 如果 n=7，有四种方法能划分集合 {1,2,3,4,5,6,7}，每一种分法的子集合各数字和是相等的：
// {1,6,7} 和 {2,3,4,5}
// {2,5,7} 和 {1,3,4,6}
// {3,4,7} 和 {1,2,5,6}
// {1,2,4,7} 和 {3,5,6}
// 给出 n，你的程序应该输出划分方案总数。

// 输入格式
// 输入文件只有一行，且只有一个整数 n。
// 输出格式
// 输出划分方案总数。

// 输入输出样例
// 输入 #1
// 7
// 输出 #1
// 4
// 说明/提示
// 【数据范围】
// 对于 100% 的数据，1≤n≤39。


// 解决这个问题，首先我们先确定是否可分
// 考虑到最后的结果要分成完全相等的两个子集，因此这n个数求和必须是偶数，否则将会无法分配
// 先偶数求和进行一步判断，接下来就是一个把指定数量的元素进行分配的背包dp问题了
// 即，有n个元素，其价值和自身编号相符（此处默认从1开始编号）
// 问应当如何分配可以使其总价值等于一个大小为n个连续正数的和的一半背包的容量
// 现在我们创建一个数组dp[i][j]，其含义为当前容量为j时，选择前i项进行分配的方案数

// 状态转移方程为：
// dp[i][j] = dp[i-1][j] + dp[i-1][j-i]

// 简单解释即为：
// 初始状态为dp[0][0] = 1，其意义为背包容量为0时，只有一种方案，就是所有数字都不选
// 当前容量为j时，选择第i个元素的方案数有两种情况决定
// 1.不选择第i个元素，即dp[i-1][j]，此时就是直接继承了上一个使用数字为i-1，容量为j的方案数
// 2.选择第i个元素，即dp[i-1][j-i]，此时就是选择数字为i本身是一种方案，又要让它继承此前容量为j-i时的方案数

// 最终，参照以上过程，我们就可以完成对这个问题的状态转移求解
// 最后要解的总结果数其实是使用i个元素时，对容量为sum/2的背包的方案数

// 具体说一些细节：
// for (int i = 1; i <= n; i++)
// {
//     for (int j = 0; j <= n * (n + 1) / 2; j++)
//     {
//         dp[i][j] = dp[i - 1][j];
//         if (j >= i)
//         {
//             dp[i][j] += dp[i - 1][j - i];
//         }
//     }
// }
// 这是状态转移方程的呈现代码
// 其中的if(j >= i)部分实际上就是在判断当前背包总容量是否可以装得下下一个数字i
// 若可以，那就正常进行对于数字i是否选择的判断
// 否则，则无法进行选择，只能选择不选择数字i，即dp[i][j] = dp[i - 1][j]

#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    if (n * (n + 1) / 2 % 2)
    {
        cout << 0 << endl;
    }
    else
    {
        long long int dp[40][1000] = {};//开longlong防止n=39时爆int
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
        {
            for (int j = 0; j <= n * (n + 1) / 2; j++)
            {
                dp[i][j] = dp[i - 1][j];
                if (j >= i)
                {
                    dp[i][j] += dp[i - 1][j - i];
                }
            }
        }
        cout << dp[n][n * (n + 1) / 4] / 2 << endl;//因为我们考虑的方案数实际上并没有区分正反，例如{1,6,7} 和 {2,3,4,5}
                                                   //在我们的解法中都可以视为一种背包填充的方案，因此最终结果需要除以2 
    }
    return 0;
}