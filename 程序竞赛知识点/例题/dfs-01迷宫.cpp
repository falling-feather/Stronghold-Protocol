//note P1141 01迷宫
//! 时间限制
// 1.00s
//! 内存限制
// 128.00MiB
//! 题目描述
// 有一个仅由数字 0 与 1 组成的 n×n 格迷宫。
//若你位于一格 0 上，那么你可以移动到相邻 4 格中的某一格 1 上，同样若你位于一格 1 上，那么你可以移动到相邻 4 格中的某一格 0 上。
// 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。
//! 输入格式
// 第一行为两个正整数 n,m。
// 下面 n 行，每行 n 个字符，字符只可能是 0 或者 1，字符之间没有空格。
// 接下来 m 行，每行两个用空格分隔的正整数 i,j，对应了迷宫中第 i 行第 j 列的一个格子，询问从这一格开始能移动到多少格。
//! 输出格式
// m 行，对于每个询问输出相应答案。
//! 输入输出样例
//?输入#1
// 2 2
// 01
// 10
// 1 1
// 2 2
//? 输出#1
// 4
// 4
//! 说明/提示
// 对于样例，所有格子互相可达。
// 	对于 20% 的数据，n≤10；
// 	对于 40% 的数据，n≤50；
// 	对于 50% 的数据，m≤5；
// 	对于 60% 的数据，n,m≤100；
// 	对于 100% 的数据，1≤n≤1000，1≤m≤100000。

//note 01迷宫解析
// 题目大意为：01迷宫，0为空，1为障碍，01迷宫中，0可以移动到1，1可以移动到0，求从某一格开始能移动到多少格。
// 解决此题，我们采用dfs算法进行遍历搜索。
// zw构建创建一个二维数组migong[1145][1145]，用于存储迷宫的01矩阵。
// zw创建一个二维数组zouguo[1145][1145]，用于记录迷宫中已经访问过的格子。
// zw创建一个二维数组f[1145][1145]，用于记录从某一格开始能移动到的格子的个数。
// zw创建一个二维数组ans[100002]，用于记录每个询问的答案。
// zw创建一个函数dfs()，用于进行dfs搜索。
// 其中dfs()函数为算法的核心，参数为当前格子的坐标x,y，当前格子的值z，当前格子的编号lll，迷宫的维数n。

// ?算法逻辑为：
// zw1. 判断当前格子坐标是否越界，或者当前格子是否已经访问过，或者当前格子的值与当前格子的坐标值不一致，则返回0。
// zw2. 将当前格子的值赋给f数组，表示当前格子已经访问过。
// zw3. 将当前格子的编号赋给ans数组，表示当前格子已经访问过。
// zw4. 计数变量count初始化为1，表示当前格子可以移动到的格子数。
// zw5. 遍历当前格子的四个方向，判断是否越界，是否已经访问过，是否与当前格子的值一致，如果满足条件，则进行dfs搜索，并累加count。




#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
int migong[1145][1145];
bool zouguo[1145][1145];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int ans[100002], f[1145][1145];

int dfs(int x, int y, int z, int lll, int n)
{
    if (x < 0 || x >= n || y < 0 || y >= n || f[x][y] != -1 || migong[x][y] != z)
        return 0;
    f[x][y] = lll;
    ans[lll]++;
    int count = 1;
    for (int i = 0; i < 4; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        count += dfs(nx, ny, !z, lll, n);
    }
    return count;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            char c;
            cin >> c;
            migong[i][j] = c - '0';
        }
    }
    memset(f, -1, sizeof(f));
    memset(ans, 0, sizeof(ans));
    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        a--; b--;
        if (f[a][b] == -1)
            dfs(a, b, migong[a][b], i, n);
        else
            ans[i] = ans[f[a][b]];
    }
    for (int i = 0; i < m; i++)
        cout << ans[i] << endl;
    return 0;
}