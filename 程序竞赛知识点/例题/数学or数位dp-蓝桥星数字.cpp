// P12835 [蓝桥杯 2025 国 B] 蓝桥星数字

// 题目描述
// 地球上，我们习惯用十进制数字来记录万物，从个位、十位，逐级向上构成了我们熟悉的自然数体系。
// 然而，在遥远的蓝桥星，数字的排列和解读方式却与我们截然不同。蓝桥星人并不单纯地以数值大小来衡量一个数字，他们更注重数字内部蕴含的“节奏感”。
// 因此，对他们而言，任何一个有效的数字，其从左到右每一位上的数字奇偶性都必须是交替出现的。
// 例如，对于 10 这个数字，其十位是奇数 1，个位是偶数 0，呈现奇偶交替，因此 10 是个有效的数字。
// 而对于 13 这个数字，其十位是奇数 1，个位也是奇数 3，不符合奇偶交替的条件，因此 13 不是个有效的数字。
// 根据这个规则，蓝桥星的数字序列从 10 开始，依次为 10,12,14,16,18,21,23,25,27,29,30,…
// 只不过，随着文明的发展，蓝桥星人需要一种方法，来快速找到第 N 个符合这种奇偶交替规则的数字，以满足其日益增长的数字处理需求。
// 现在，请你帮助蓝桥星人，编写程序找出并输出第 N 个符合奇偶交替规则的数字。

// 输入格式
// 输入包含一个正整数 N，表示需要查找第 N 个符合规则的数字。

// 输出格式
// 输出一个整数，表示第 N 个符合奇偶交替规则的数字。

// 输入输出样例
// 输入#1
// 输出#10

// 输入#11
// 输出#30


// 首先，这道题的数据规模是10的12次方以内，在判断的时候需要注意这一点。
// 我在解题就是没有注意到这一点，导致花了一个多小时来调算法无果，最后改了一下数组大小。过了……
// 关于这道题的具体解法，我们考虑一下题干的意思，大意就是说会构成一个五进制的新数字，只不过新的数字的五进制并不是单纯的五进制
// 对于首位数字，其是完全自由的，会有9种可能，此后的每一位数字因为奇偶交错的关系，只有5种
// 由此迭代，对于两位数字，一共应该有9*5=45种可能
// 对于三位数字，一共应该有9*5*5=225种可能
// 对于四位数字，一共应该有9*5*5*5=1125种可能
// 后续不再赘述
// 所以我的解题方法是，先打表构建一个数值biao，这个数组的作用就是提前算出每个位数对应的数字数量，以便于我后续快速地定位原始数字的位数
// 这个打表的过程需要考虑到本题的数据规模，我最开始打得是16位，这并不足够，因为10的12次方有13位数字，16位表只装得下12位
// 正确打表后，逐位比较数目大小，最终由此判断出一个位数len
// 在找到位数len后,我们就要从最大到最小开始逐步确定数字了,我们的方案是用五进制思维逆向计算:
// 首先,把输入的n先剔除所有的len-1位的数字数目,只保留len位数字.
// 然后，我们从最高位开始逐步让剩下的n除以5的len-i-1次，考虑到cpp种pow计算是double式结果，精度不够，所以我们仿照biao的获取直接优化一个5的幂函数
// 接下来的计算就简单了，采用五进制思维逐步判断出这一位上的数字对应第几位，然后再回过头来看前一位数字，判断他的奇偶性，分别计算就好了

// 我们来举一个样例说明一下：
// 当输入48时，首先打表发现len=3，也就是初始数字应该是一个三位数，那么用48-1 / 45，得到1，就说明这个数字的最高位应当是1。
// 再然后，我们开始逐步往后确定，48-1 % 45 = 3，对于第二位我们先用3-1 / 5，得到0，那么第二位数字应当是对应此位数上的第一个数字
// 对于第三位，我们仅剩3-1 / 1，得到2，那么这一位对应的其实就是第三个数字了
// 明确了每一位上是第几个数字，我们再推算一下，不难根据奇偶性得到对应的应该是105，经过简单计算完全正确。
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long int biao[20];
    biao[0] = 45;
    for (int i = 1; i < 20; i++)
    {
        biao[i] = biao[i - 1] * 5;
    }// 这里是在构建打表数组biao
    long long int n;
    cin >> n;
    int len = 2;
    for (int i = 0; i < 20; i++)
    {
        if (n > biao[i])
        {
            len += 1; 
            n -= biao[i];
        }
        else
        {
            break;
        }
    }//这里是在求数组的位数，单纯的加减比较就可以了，每比较一位结束之后就把这一位的数目清空
    long long int pow5[20];
    pow5[0] = 1;
    for (int i = 1; i < 20; i++) 
    {
        pow5[i] = pow5[i-1] * 5;
    }

    vector<int> ans(len);
    int first = (n - 1) / pow5[len - 1] + 1;
    ans[0] = first;
    long long int oth = (n - 1) % pow5[len - 1];//之所以-1是因为我们的计数是从0开始的，0-4，实际上就算不减也没什么大事，后边再补上就好了
    for (int i = 1; i < len; i++)
    {
        int chang = len - i - 1;  
        int num = oth / pow5[chang];  
        oth = oth % pow5[chang];  //每次计算后，都仿照5进制的方式把剩余数字传递到下一位
        
        if (ans[i-1] % 2 == 0)//因为我们是先算的第一位，所以后面的奇偶判断都可以考虑用前一位进行传递
        {
            ans[i] = num * 2 + 1;  
        }
        else
        {
            ans[i] = num * 2;  
        }
    }
    for (int i = 0; i < len; i++)
    {
        cout << ans[i];
    }
    cout << endl;
    return 0;
}