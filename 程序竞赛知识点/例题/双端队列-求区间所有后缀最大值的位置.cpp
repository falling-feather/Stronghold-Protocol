//note B3667 求区间所有后缀最大值的位置
//! 时间限制1.00s
//! 内存限制512.00MiB
//! 题目描述
// 给定一个长度为 n 的数列 a，对于其中每个长度为 k 的子区间，请你求出这个这个子区间构成的数列的所有后缀最大值的位置个数。
// 一个下标 i 是是数列 b 的后缀最大值下标当且仅当：对于所有的 i<j≤∣b∣，都有 b_i>b_j，其中 ∣b∣ 表示 b 的元素个数。
//! 输入格式
// 第一行是两个整数，依次表示操作次数 n 和子区间长度 k。
// 第二行有 n 个整数，第 i 个整数表示 a_i。
//! 输出格式
// 共输出 n-k+1 行每行一个整数，按左端点从小到大的顺序依次输出每个子区间构成的数列的后缀最大值位置个数。
// 输入输出样例
//? 输入#1
// 5 3
// 2 1 3 5 4
//? 输出#1
// 1
// 1
// 2
//? 说明/提示
//? 样例 1 解释
//zw 第一个子数列：2,1,3。其中 3 是后缀最大值。
//zw 第二个子数列：1,3,5，其中 5 是后缀最大值。
//zw 第三个子数列：3,5,4，其中 5 和 4 是后缀最大值。
//? 数据规模与约定
// 对于全部的测试点，保证 1≤k≤n≤10^6，1≤x_i<2^64。

//note 解析：
// 很容易就可以想到，用暴力方法求解：
// 每输入一个数，将其与之前的所有后缀最大值的数遍历，
// 如果比它大，那么就将比它小的那个数删除，再判断队列最前面的数是不是第 l−k+1 个数即可。

// 利用双端队列这个数据结构，将当时的后缀最大值入队列，
// 如果遍历后不是后缀最大值了，那么便出队列，每次操作判断是不是第 l−k+1 个数，
// 若是，则将那个数出队列。
// 便可以得到以下核心代码：

//zw 如果当前队列不为空并且当前队列的第一个数已经不在区间内了，则将队首的数出队列。
// if (q.size() && (q.front() + k - 1) < i) q.pop_front();
//zw 如果当前队列不为空并且当前数比队尾的数大，则将队尾的数出队列。
// while(q.size() && a[i] > a[q.back()])
// {
//     q.pop_back();
// }
//zw 每次考虑让新的头元素索引入队，因为他本身一定是一个后缀最大值
// q.push_back(i);


#include <bits/stdc++.h>
using namespace std;
int a = 100;
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, k;
    cin >> n >> k;
    unsigned long long int a[n];
    deque<unsigned long long int> q;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        if (q.size() && (q.front() + k - 1) < i) q.pop_front();
        while(q.size() && a[i] > a[q.back()])
        {
            q.pop_back();
        }
        q.push_back(i);
        if (i >= k - 1) cout << q.size() << endl;
    }
    return 0;
}
