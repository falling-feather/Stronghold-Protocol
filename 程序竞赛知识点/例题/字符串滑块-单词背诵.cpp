// P1381 单词背诵
// 时间限制
// 1.00s
// 内存限制
// 125.00MiB
// 题目描述
// 灵梦有 n 个单词想要背，但她想通过一篇文章中的一段来记住这些单词。
// 文章由 m 个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。
// 输入格式
// 第 1 行一个数 n，接下来 n 行每行是一个长度不超过 10 的字符串，表示一个要背的单词。
// 接着是一个数 m，然后是 m 行长度不超过 10 的字符串，每个表示文章中的一个单词。
// 输出格式
// 输出文件共 2 行。第 1 行为文章中最多包含的要背的单词数，第 2 行表示在文章中包含最多要背单词的最短的连续段的长度。
// 输入输出样例
// 输入#1
// 3
// hot
// dog
// milk
// 5
// hot
// dog
// dog
// milk
// hot
// 输出#1
// 3
// 3
// 说明/提示
// 数据规模与约定
// 	对于 30% 的数据，n≤50，m≤500；
// 	对于 60% 的数据，n≤300，m≤5000；
// 	对于 100% 的数据，1≤n≤1000，1≤m≤10^5。

// AI解析：
// 滑动窗口算法详解：背单词问题
// 问题本质理解
// 这个问题就像是在一个糖果商店里找宝藏：

// 你有一份购物清单（要背的单词）
// 商店里有一排商品架（文章中的单词）
// 你要找到一段连续的商品区域，包含清单上所有的物品，并且这段区域要尽可能短
// 核心算法：双指针滑动窗口
// 比喻理解
// 想象你拿着一个可伸缩的夹子在商品架上操作：

// cpp
// int left = 0;     // 夹子左端
// int right = 0;    // 夹子右端（通过for循环的i变量控制）
// 操作策略：

// 右手扩张：右端不断向右移动，把新商品夹进来
// 左手收缩：一旦夹子包含了所有需要的商品，左手就尝试向右移动缩小夹子
// 记录最优：在这个过程中记录最小的夹子长度
// 状态追踪系统
// 为了知道夹子里有多少种需要的商品，我们设置了两个关键变量：

// cpp
// int num = 0;              // 当前夹子里不同目标商品的种类数
// map<string, int> count;   // 每种目标商品在夹子里的数量
// 增加商品时：

// cpp
// count[b]++;               // 该商品数量+1
// if(count[b] == 1)         // 如果是第一次夹到这种商品
//     num++;                // 不同商品种类数+1
// 移除商品时：

// cpp
// count[left]--;            // 该商品数量-1
// if(count[left] == 0)      // 如果这种商品完全被移除了
//     num--;                // 不同商品种类数-1
// 完整流程图解
// 第一阶段：准备工作
// cpp
// // 统计要背的单词（购物清单）
// map<string, int> bs;
// for(int i = 0; i < n; i++) {
//     string s;
//     cin >> s;
//     bs[s] = 1;  // 标记为目标单词
// }

// // 检查文章中实际出现了哪些目标单词
// int sum = 0;  // 文章中实际包含的不同目标单词数
// 第二阶段：特殊情况处理
// cpp
// if (sum == 0) {
//     cout << 0 << endl;  // 文章中没有要背的单词
//     return 0;
// }
// 第三阶段：滑动窗口主逻辑
// cpp
// for (int i = 0; i < m; i++) {  // 右指针遍历
//     // 扩张：夹入新单词
//     string b = v[i];
//     if (bs[b]) {  // 如果是目标单词
//         count[b]++;
//         if(count[b] == 1) num++;  // 新增一种目标单词
//     }
    
//     // 收缩：优化窗口
//     while (num == sum && l <= i) {  // 包含所有目标单词时
//         minlenth = min(minlenth, i - l + 1);  // 更新最优解
        
//         // 移除最左边的单词
//         string left = v[l];
//         if (bs[left]) {
//             count[left]--;
//             if (count[left] == 0) num--;
//         }
//         l++;  // 左指针右移
//     }
// }
// 关键技巧总结
// 1. 双指针协调机制
// 右指针负责"收集"：不断扩大范围直到满足条件
// 左指针负责"优化"：在满足条件的前提下尽量缩小范围
// 交替进行：不是同时移动，而是有先后顺序
// 2. 状态维护要点
// 用计数器精确追踪每种目标元素的数量
// 用种类数快速判断是否满足整体条件
// 及时更新状态避免重复计算
// 3. 边界情况处理
// 空集合：当没有任何目标元素时直接返回
// 指针约束：始终保持 left ≤ right
// 初始化：合理设置初始值避免误判
// 适用场景
// 这种滑动窗口技巧适用于以下问题：

// 找包含特定元素的最短/最长连续子数组
// 找和为特定值的连续子数组
// 找包含特定字符的最短子串
// 任何需要在连续区间内满足某种条件的优化问题
// 掌握了这套"夹子法"思维，遇到类似的连续区间优化问题就能迎刃而解了！


#include <bits/stdc++.h>
using namespace std;

int main() 
{
    map<string, int> bs;
    map<string, bool> nums;
    int n;
    cin >> n;
    int sum = 0;
    for(int i = 0; i < n; i++)
    {
        string s;
        cin >> s;
        bs[s] = 1;
    }
    int m;
    cin >> m;
    vector<string> v;
    for (int i = 0; i < m; i++)
    {
        string s;
        cin >> s;
        v.push_back(s);
        if (bs[s] && !nums[s]) sum++, nums[s] = true;
    }
    cout << sum << endl;
    if (sum == 0) 
    {
        cout << 0 << endl;
        return 0;
    }
    
    int l = 0;
    int num = 0;
    map<string, int> count;
    int minlenth = m;
    for (int i = 0; i < m; i++)
    {
        string b = v[i];
        if (bs[b])
        {
            count[b]++;
            if(count[b] == 1)   num++;
        }
        while (num == sum && l <= i)
        {
            minlenth = min(minlenth, i - l + 1);
            string left = v[l];
            if (bs[left])
            {
                count[left]--;
                if (count[left] == 0) num--;
            }
            l++;
        }
    }
    cout << minlenth << endl;   
    return 0;
}
