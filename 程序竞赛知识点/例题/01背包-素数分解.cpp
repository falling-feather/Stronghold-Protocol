// B4141 [信息与未来 2016] 素数分解
// 题目描述
// 素数，又称质数，是指除 1 和其自身之外，没有其他约数的正整数。
// 例如，2,3,5,7,13 都是质数，而 4,9,12,18 则不是。
// 虽然素数不能分解成除 1 和其自身之外整数的乘积，
// 但却可以分解成更多素数的和。
// 你需要编程求出一个正整数最多能分解成多少个互不相同的素数的和。

// 输入格式
// 一行一个正整数 n。

// 输出格式
// 一行一个正整数，表示 n 最多能分解成多少个不同的素数的和。

// 输入输出样例
// 输入 #1
// 21
// 输出 #1
// 4
// 输入 #2
// 128
// 输出 #2
// 9
// 说明/提示
// 样例 1 解释
// 21=2+3+5+11。

// 数据范围
// 10≤n≤200。

// 保证有解。



// 解题时采用了先打表获得所有素数，然后进行01背包dp的方法。核心思路为：
// 举例说明
// 假设 n = 10，我们来看看执行过程：

// 初始状态
// dp = [0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
// 索引: 0   1   2   3   4   5   6   7   8   9   10
// 处理素数2
// 遍历 j 从 10 到 2：

// j=10: dp[10-2]=dp[8]=-1，不更新
// j=9: dp[9-2]=dp[7]=-1，不更新
// ...
// j=2: dp[2-2]=dp[0]=0!=-1，所以 dp[2]=max(-1, 0+1)=1
// 结果：

// dp = [0, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1]
// 处理素数3
// 遍历 j 从 10 到 3：

// j=10: dp[10-3]=dp[7]=-1，不更新
// j=9: dp[9-3]=dp[6]=-1，不更新
// ...
// j=3: dp[3-3]=dp[0]=0!=-1，所以 dp[3]=max(-1, 0+1)=1
// 结果：

// dp = [0, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1]
// 继续处理素数5：

// j=10: dp[10-5]=dp[5]=-1，不更新
// j=9: dp[9-5]=dp[4]=-1，不更新
// ...
// j=5: dp[5-5]=dp[0]=0!=-1，所以 dp[5]=max(-1, 0+1)=1
// 结果：

// dp = [0, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]
// 处理素数7
// j=10: dp[10-7]=dp[3]=1!=-1，所以 dp[10]=max(-1, 1+1)=2
// j=9: dp[9-7]=dp[2]=1!=-1，所以 dp[9]=max(-1, 1+1)=2
// j=8: dp[8-7]=dp[1]=-1，不更新
// j=7: dp[7-7]=dp[0]=0!=-1，所以 dp[7]=max(-1, 0+1)=1
// 最终结果：

// dp = [0, -1, 1, 1, -1, 1, -1, 1, -1, 2, 2]
// 所以答案是 dp[10] = 2，表示10最多能分解成2个不同素数的和（例如：3+7=10）。


#include <bits/stdc++.h>
using namespace std;
int a[50]={2,3,5,7,11,13,17,19,23,29,31,37,
    41,43,47,53,59,61,67,71,73,79,83,89,97,
    101,103,107,109,113,127,131,137,139,149,
    151,157,163,167,173,179,181,191,193,197,199};
int main()
{
    int n ;
    cin >> n;
    vector<int> dp(n + 1, -1);
    dp[0] = 0;
    for (int i : a)
    {
        if(i > n) break;
        for (int j = n; j >= i ; j--)
        {
            if (dp[j - i] != -1)
            {
                dp[j] = max(dp[j], dp[j - i] + 1);
            }
        }
    }
    cout << dp[n] << endl;
    return 0;
}